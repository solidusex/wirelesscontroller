%code {:
/*
 * The Arsenal Library
 * Copyright (c) 2009 by Solidus
 * 
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.It is provided "as is" without express 
 * or implied warranty.
 *
 */
:}
;



/******************************************PreDefined code********************************************/
%code syntax_node {:

    typedef enum
    {
        TGU_NODE_TOKEN_T,
        TGU_NODE_STMT_T,
        TGU_NODE_EXPR_T,
        TGU_NODE_SYMB_T,
        TGU_NODE_PARAMS_T,
        TGU_NODE_FUNC_T
    }tguSynNodeType_t;

    typedef struct __tengu_syntax_node_tag
    {
        tguSynNodeType_t        type;
        
        union{
                tguToken_t            token;
                tguStmt_t            *stmt;
                tguExpr_t            *expr;
                tguParams_t            *params;
                tguSymb_t            *symb;
        };
    }tguSynNode_t;


    static tguSynNode_t*    __create_synnode(tguSynNodeType_t type, void *data)
    {
            tguSynNode_t *node;

            node = AR_NEW0(tguSynNode_t);
            node->type = type;

            switch(node->type)
            {
            case TGU_NODE_TOKEN_T:
                node->token = *(tguToken_t*)data;
                break;
            case TGU_NODE_STMT_T:
                node->stmt = (tguStmt_t*)data;
                break;
            case TGU_NODE_EXPR_T:
                node->expr = (tguExpr_t*)data;
                break;
            case TGU_NODE_SYMB_T:
                node->symb = (tguSymb_t*)data;
                break;
            case TGU_NODE_PARAMS_T:
                node->params = (tguParams_t*)data;
                break;
            }

            return node;
    }


    static void    __destroy_synnode(    tguSynNode_t* node)
    {
        AR_ASSERT(node != NULL);
        switch(node->type)
        {
        case TGU_NODE_TOKEN_T:
            break;
        case TGU_NODE_STMT_T:
            if(node->stmt)
            {
                TGU_DestroyStmt(node->stmt);
                node->stmt = NULL;
            }
            break;
        case TGU_NODE_EXPR_T:
            if(node->expr)
            {
                tguExpr_t    *expr = node->expr;
                while(expr)
                {
                    tguExpr_t    *tmp = expr->next;
                    TGU_DestroyExpr(node->expr);
                    expr = tmp;
                }
                node->expr = NULL;
            }
            break;
        case TGU_NODE_SYMB_T:
            if(node->symb)
            {
                TGU_DestroySymb(node->symb);
                node->symb = NULL;
            }
            break;
        case TGU_NODE_PARAMS_T:
            if(node->params)
            {    
                TGU_DestroyParams(node->params);
                node->params = NULL;
            }
            break;
        }

        AR_DEL(node);
    }
:}
;





%code syntax_tree_handler {:

    static void        AR_STDCALL on_free_node(psrNode_t *node, void *ctx)
    {
        AR_ASSERT(node != NULL && ctx != NULL);
        __destroy_synnode((tguSynNode_t*)node);
        
    }

    static bool_t        AR_STDCALL on_error(const psrToken_t *tok, const size_t expected[], size_t count, void *ctx)
    {
            tguParser_t    *parser;
            size_t        i;
            arString_t    *str;
            wchar_t        *tok_str;
            AR_ASSERT(tok != NULL && ctx != NULL);

            parser = (tguParser_t*)ctx;
            str = AR_CreateString();

            if(tok->term_val == 0)
            {
                    tok_str = AR_wcsdup(L"EOI");
            }else
            {
                    tok_str = AR_wcsndup(tok->str, tok->str_cnt);
            }
        
            AR_AppendFormatString(str, L"Invalid token : '%ls', expected ", tok_str);
            
            for(i = 0; i < count; ++i)
            {
                    AR_AppendFormatString(str, L"'%ls'", TGU_TokenValToString(expected[i]));
            }
            
            TGU_ReportError(&parser->report, AR_GetStringCString(str), tok->line);
        
            AR_DestroyString(str);
            str = NULL;
            AR_DEL(tok_str);
            tok_str = NULL;
            return true;
    }
    
    static const psrHandler_t    __g_handler = {on_error, on_free_node};
:}
;








%name    delim             :     "[\x{000A}\x{000B}\x{000C}\x{000D}\x{0085}\x{2028}\x{2029}\x{0020}\f\n\r\t\v\x{0009}\x{0020}\x{00A0}\x{1680}\x{180E}\x{2000}-\x{200A}\x{202F}\x{205F}\x{3000}]"
                        ;

%name    comment        :    "/\*([^\*]|\*+[^\*/])*\*+/"    
                       ;

%name    comment_line        :    "(//[^\x{000A}\x{000B}\x{000C}\x{000D}\x{0085}\x{2028}\x{2029}]*(\x{000A}|\x{000B}|\x{000C}|\x{000D}|\x{0085}|\x{2028}|\x{2029}|$))"
                          ;

%name skip_lexem        :     "{delim}|{comment_line}|{comment}"
                ;


%name    digit                :    "[0-9]"                
                        ;

%name    number                :    "{digit}+"                
                        ;


/*
\x{4E00}-\x{9FA5}     (中文)
\x{3130}-\x{318F}     (韩文)
\x{AC00}-\x{D7A3}    (韩文)
\x{0800}-\x{4E00}    (日文)
*/

//ASCII + 中日韩

%name    letter                :    "[A-Z_a-z\x{0800}-\x{4E00}\x{4E00}-\x{9FA5}\x{3130}-\x{318F}\x{AC00}-\x{D7AF}]"
                        ;



%name hex_digit            :    "[0-9a-fA-F]"
                        ;


%name hex_literal             :    "0(x|X){hex_digit}+"
                        ;

%name oct_literal            :    "0[0-7]+"
                        ;

%name dec_literal            :    "(0|[1-9][0-9]*)"
                        ;




%name    exponet               :    "(e|E)(\+|\-)?[0-9]+"
                            ;

%name float_literal           :    "(((([0-9]\.[0-9]*)){exponet}?)|([0-9]+{exponet}))"
                            ;




/*  '"'  == \x22,  '\'' == \x27 */

%name    escape_seq        :    "(\\(\x22|\x27))"    
                ;

%name    string_dq        :     "(\x22({escape_seq}|[^\x22])*\x22)"        //只能提取"..."或"\""此类串，其它词法规则要到语义例程中处理    
                ;

%name    string_sq        :    "\x27({escape_seq}|[^\x27])*\x27"        //提取'...'或'\''此类串，其它词法规则要到语义例程中处理    
                ;



%name    keyword_lhd           :    "[A-Z_a-z0-9]"
                        ;


%name        float_constant    :    "{float_literal}(?!{keyword_lhd})"
                    ;
%name        hex_constant        :    "{hex_literal}(?!{keyword_lhd})"
                    ;
%name        oct_constant        :    "{oct_literal}(?!{keyword_lhd})"
                    ;
%name        dec_constant        :    "{dec_literal}(?!{keyword_lhd})"
                    ;


%token     %skip            :    "{skip_lexem}"                ,1                %value    "TOK_DELIM_ID"             ;            //空白，需要过滤



%code token_operation{:
    
    static tguSynNode_t*    on_lex_node(tguParser_t *parser, const wchar_t *str, size_t term_val, size_t line, size_t col)
    {
        tguToken_t token;
        AR_ASSERT(parser != NULL && parser->module_name);
        token.token = str;
        token.term_val = term_val;
        token.lex_info.linenum = line;
        token.lex_info.col = col;
        token.lex_info.module_name = parser->module_name;
        return __create_synnode(TGU_NODE_TOKEN_T, (void*)&token);
    }

:}
;



%token        NAME        :    "{letter}({letter}|{digit})*"                    %value    "TOK_NAME"            %action default_leaf_handler        
                {:
                    tguParser_t    *parser = (tguParser_t*)ctx;
                    const wchar_t    *term_str = NULL;
                    AR_ASSERT(parser != NULL && tok != NULL);
                    AR_ASSERT(tok->str_cnt > 0);
                    term_str = TGU_AllocStringN(tok->str, tok->str_cnt);
                    return on_lex_node(parser, term_str, tok->term_val, tok->line, tok->col);
                :}
                ;


%token        STRING        :    "{string_dq}|{string_sq}"                        %value    "TOK_STRING"            %action on_string_leaf_handler        
                {:
                    arEscStrErr_t    err;
                    tguParser_t    *parser = (tguParser_t*)ctx;
                    wchar_t    *str = NULL;
                    const wchar_t *term_str;
                    AR_ASSERT(parser != NULL && tok != NULL);
                    AR_ASSERT(tok->str_cnt >= 2);            
                    AR_ASSERT(tok->str[0] == L'"' || tok->str[0] == L'\'');
                    AR_ASSERT(tok->str[tok->str_cnt-1] == L'"' || tok->str[tok->str_cnt-1] == L'\'');

                    str = AR_escstr_to_str_n(tok->str + 1, tok->str_cnt - 2, &err);
                    if(str == NULL)
                    {
                        wchar_t    msg[1024];
                        parser->has_error = true;
                        AR_swprintf(msg, 1024, L"error : character escape sequence");
                        TGU_ReportError(&parser->report, msg, tok->line);
                    }
                    term_str = TGU_AllocString(str == NULL ? L"" : str);
                    
                    if(str)
                    {
                        AR_DEL(str);
                        str = NULL;
                    }

                    return on_lex_node(parser, term_str, tok->term_val, tok->line, tok->col);
                :}
                ;


%token        FLOAT_NUMBER    :    "{float_constant}"                        ,2    %value    "TOK_FLOAT_NUMBER"        %action default_leaf_handler        ;
%token        INT_NUMBER    :    "{hex_constant}|{oct_constant}|{dec_constant}"        ,2    %value    "TOK_INT_NUMBER"        %action default_leaf_handler        ;







%token    "for"        :    '"for"(?!{keyword_lhd})'        ,1            %value    "TOK_FOR"            %action default_leaf_handler            ;
%token    "do"        :    '"do"(?!{keyword_lhd})'        ,1            %value    "TOK_DO"            %action default_leaf_handler            ;
%token    "while"    :    '"while"(?!{keyword_lhd})'        ,1            %value    "TOK_WHILE"            %action default_leaf_handler            ;
%token    "if"        :    '"if"(?!{keyword_lhd})'        ,1            %value    "TOK_IF"            %action default_leaf_handler            ;
%token    "else"        :    '"else"(?!{keyword_lhd})'        ,1            %value    "TOK_ELSE"            %action default_leaf_handler            ;

%token    "continue"    :    '"continue"(?!{keyword_lhd})'    ,1            %value    "TOK_CONTINUE"        %action default_leaf_handler            ;
%token    "break"    :    '"break"(?!{keyword_lhd})'        ,1            %value    "TOK_BREAK"            %action default_leaf_handler            ;
%token    "return"    :    '"return"(?!{keyword_lhd})'        ,1            %value    "TOK_RETURN"            %action default_leaf_handler            ;

%token    "null"        :    '"null"(?!{keyword_lhd})'        ,1            %value    "TOK_NULL"            %action default_leaf_handler            ;
%token    "true"        :    '"true"(?!{keyword_lhd})'        ,1            %value    "TOK_TRUE"            %action default_leaf_handler            ;
%token    "false"    :    '"false"(?!{keyword_lhd})'        ,1            %value    "TOK_FALSE"            %action default_leaf_handler            ;
%token    "var"        :    '"var"(?!{keyword_lhd})'        ,1            %value    "TOK_VAR"            %action default_leaf_handler            ;

%token    "in"        :    '"in"(?!{keyword_lhd})'        ,1            %value    "TOK_IN"            %action default_leaf_handler            ;


%token    "import"    :    '"import"(?!{keyword_lhd})'        ,1            %value    "TOK_IMPORT"            %action default_leaf_handler            ;

%token    "D"        :    '"D"(?!{keyword_lhd})'        ,1            %value    "TOK_DICT"            %action default_leaf_handler            ;

%token    "L"        :    '"L"(?!{keyword_lhd})'        ,1            %value    "TOK_LIST"            %action default_leaf_handler            ;



%token    "..."        :    '"..."'    ,2                        %value    "TOK_ELLIPSIS"        %action default_leaf_handler            ;    


%token    "++"        :    '"++"'        ,1                        %value    "TOK_INC"            %action default_leaf_handler            ;
%token    "--"        :    '"--"'        ,1                        %value    "TOK_DEC"            %action default_leaf_handler            ;


%token    "&&"        :    '"&&"'        ,1                        %value    "TOK_ANDAND"            %action default_leaf_handler            ;
%token    "||"        :    '"||"'        ,1                        %value    "TOK_OROR"            %action default_leaf_handler            ;




%token    "<="        :    '"<="'        ,1                        %value    "TOK_LE"            %action default_leaf_handler            ;
%token    ">="        :    '">="'        ,1                        %value    "TOK_GE"            %action default_leaf_handler            ;
%token    "=="        :    '"=="'        ,1                        %value    "TOK_EQ"            %action default_leaf_handler            ;
%token    "!="        :    '"!="'        ,1                        %value    "TOK_NE"            %action default_leaf_handler            ;
%token    "<"        :    '"<"'            ,0                    %value    "TOK_LESS"            %action default_leaf_handler            ;
%token    ">"        :    '">"'            ,0                    %value    "TOK_GREATER"            %action default_leaf_handler                ;




%token    "{"        :    '"{"'            ,0                    %value    "TOK_L_BRACES"        %action default_leaf_handler            ;
%token    "}"        :    '"}"'            ,0                    %value    "TOK_R_BRACES"        %action default_leaf_handler            ;
%token    "("        :    '"("'            ,0                    %value    "TOK_L_PAREN"            %action default_leaf_handler            ;
%token    ")"        :    '")"'            ,0                    %value    "TOK_R_PAREN"            %action default_leaf_handler            ;
%token    "["        :    '"["'            ,0                    %value    "TOK_L_SQUARE"        %action default_leaf_handler            ;
%token    "]"        :    '"]"'            ,0                    %value    "TOK_R_SQUARE"        %action default_leaf_handler            ;

%token    ";"        :    '";"'            ,0                    %value    "TOK_SEMICOLON"        %action default_leaf_handler            ;
%token    ","        :    '","'            ,0                    %value    "TOK_COMMA"            %action default_leaf_handler            ;
%token    "="        :    '"="'            ,0                    %value    "TOK_ASSIGN"            %action default_leaf_handler            ;



%token    "+"        :    '"+"'            ,0                    %value    "TOK_ADD"            %action default_leaf_handler            ;
%token    "-"        :    '"-"'            ,0                    %value    "TOK_SUB"            %action default_leaf_handler            ;
%token    "*"        :    '"*"'            ,0                    %value    "TOK_MUL"            %action default_leaf_handler            ;
%token    "/"        :    '"/"'            ,0                    %value    "TOK_DIV"            %action default_leaf_handler            ;
%token    "%"        :    '"%"'            ,0                    %value    "TOK_MOD"            %action default_leaf_handler            ;

%token    "!"        :    '"!"'            ,0                    %value    "TOK_NOT"            %action default_leaf_handler            ;


%token    ":"        :    '":"'            ,0                    %value    "TOK_COLON"            %action default_leaf_handler            ;
%token    "?"        :    '"?"'            ,0                    %value    "TOK_QUEST"            %action default_leaf_handler            ;


%token    "."        :    '"."'            ,0                    %value    "TOK_DOT"            %action default_leaf_handler            ;





/**************************************************优先级*****************************************************/

%right        "?"    ":"                            ;
%left        "||"                                ;
%left        "&&"                                ;
%left        "=="    "!="    "<"    "<="    ">"    ">="            ;
%left        "+"    "-"                            ;
%left        "*"    "/"    "%"                        ;




/*
"if" "(" expression ")" statement "else" statement 
产生式的优先级依赖于其最右终结符或显性指定,这里就是"else"
*/
%nonassoc IF_WITHOUT_ELSE                        ;
%nonassoc "else"                            ;






/**********************************************产生式****************************************/


%start    program        ;


program            :    translation_unit            %action    on_translation_unit    
                |    .                    %action    on_translation_unit
                {:
                    tguParser_t     *parser = (tguParser_t*)ctx;
                    tguBlock_t    *result;
                    AR_ASSERT(count == 0 || count == 1);

                    AR_UNUSED(parser);
                    AR_UNUSED(result);
                    return NULL;
                :}
                ;














translation_unit        :    element                %action    auto_return_null
                |    translation_unit    element    %action    auto_return_null
                ;


element            :    declaration            %action    auto_return_null
                |    function_defination        %action    auto_return_null
                |    statement            %action    on_global_stmtement
                {:
                        
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        AR_ASSERT(ns != NULL && count == 1);
                        if(ns[0] == NULL)
                        {
                            return NULL;
                        }
                        
                        AR_ASSERT(ns[0]->type == TGU_NODE_STMT_T && ns[0]->stmt != NULL);
                        
                        AR_ASSERT(parser->top_block == parser->abs_tree);
                        TGU_InsertStmtToBlock(parser->top_block, ns[0]->stmt);
                        ns[0]->stmt = NULL;
                        return NULL;

                :}
                ;






/**************************************function_defination***********************************************/


%code    handle_function    {:
    
    static void    start_function(tguParser_t *parser, const wchar_t *func_name, const tguParams_t    *params, const tguLexInfo_t *lex_info)
    {
        size_t    i;
        AR_ASSERT(parser != NULL && func_name != NULL && lex_info != NULL);

        AR_ASSERT(parser->top_block == parser->abs_tree && parser->current_function == NULL);
        AR_ASSERT(!parser->is_on_function_compound);
        
        parser->is_on_function_compound = true;
        if(    TGU_FindSymbFromBlock(parser->abs_tree, func_name, TGU_SYMB_FUNC_T, true) != NULL 
        ||     TGU_FindSymbFromBlock(parser->abs_tree, func_name, TGU_SYMB_CFUNC_T, true) != NULL
        ||    TGU_FindSymb((tguSymbTbl_t*)parser->ext->build_in, func_name, TGU_SYMB_FUNC_T) != NULL
        ||    TGU_FindSymb((tguSymbTbl_t*)parser->ext->build_in, func_name, TGU_SYMB_CFUNC_T) != NULL
        )
        {
            wchar_t    msg[1024];
            parser->has_error = true;
            parser->on_redef_function = true;
            AR_swprintf(msg, 1024, L"error : function '%ls' : redefinition",  func_name);
            TGU_ReportError(&parser->report, msg, lex_info->linenum);
        }else
        {
            tguSymb_t    *symb = TGU_CreateSymb(TGU_SYMB_FUNC_T, func_name);
            symb->lex_info = *lex_info;
            symb->function = NULL;
            TGU_InsertSymbToBlock(parser->abs_tree, symb);
        }

        parser->current_function = TGU_CreateFunction(func_name, parser->abs_tree);
        parser->top_block = parser->current_function->block;
        parser->current_function->is_variadic_param = params ? params->is_variadic : false;
        
        
        for(i = 0; params != NULL && i < params->count; ++i)
        {
            tguSymb_t    *symb;
            tguBlock_t    *block = parser->current_function->block;
            const wchar_t    *name = params->names[i];
            const tguLexInfo_t    lex_info = params->lex_info[i];
            AR_ASSERT(name != NULL);

            symb = TGU_FindSymbFromBlock(block, name, TGU_SYMB_VAR_T, true);

            if(symb)
            {
                wchar_t    msg[1024];
                parser->has_error = true;
                AR_swprintf(msg, 1024, L"error : '%ls' : redefinition",  name);
                TGU_ReportError(&parser->report, msg, lex_info.linenum);
            }else
            {
                symb = TGU_CreateSymb(TGU_SYMB_VAR_T, name);
                symb->lex_info = lex_info;
                TGU_InsertSymbToBlock(block, symb);
            }
        }
        
        AR_ASSERT(parser->top_block != NULL);
        
    }
    

    static void    close_function(tguParser_t *parser, tguStmt_t    *stmt)
    {
        tguFunc_t    *func;
        bool_t        is_redef_func = false;
        AR_ASSERT(parser != NULL);
        AR_ASSERT(parser->top_block== parser->abs_tree && parser->current_function != NULL);
        AR_ASSERT(stmt->stmt_type == TGU_STT_COMPOUND && stmt->compound_stmt.block == parser->current_function->block);
        func = parser->current_function;
        parser->current_function = NULL;
        parser->is_on_function_compound = false;
        is_redef_func = parser->on_redef_function;
        parser->on_redef_function = false;
        stmt->compound_stmt.block = NULL;
        TGU_DestroyStmt(stmt);
        if(is_redef_func)
        {
            TGU_DestroyFunction(func);
            func = NULL;
        }else
        {
            tguSymb_t    *symb = NULL;
            symb = TGU_FindSymbFromBlock(parser->abs_tree, func->name, TGU_SYMB_FUNC_T, true);
            AR_ASSERT(symb != NULL && symb->function == NULL);
            symb->function = func;
        }
        
            
    }
:}
;


function_signature        :    "var"        NAME "(" params ")"                        %action    on_function_signature
                {:
                        tguParser_t     *parser = (tguParser_t*)ctx;
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguToken_t        name;
                        tguLexInfo_t        lex_info;
                        tguParams_t        *params;
                        AR_ASSERT(ns[0] != NULL && ns[1] != NULL);

                        lex_info = ns[0]->token.lex_info;
                        name = ns[1]->token;
                        if(ns[3] == NULL)
                        {
                            params = NULL;
                        }else
                        {
                            params = ns[3]->params;
                            AR_ASSERT(params != NULL);
                        }
                        
                        start_function(parser, name.token, params, &lex_info);
                        return NULL;
                :}
                ;


function_defination        :    function_signature    compound_statement    %action    on_function_defination
                {:
                        tguParser_t     *parser = (tguParser_t*)ctx;
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguStmt_t    *stmt;
                        if(ns[1] != NULL)
                        {
                            stmt = ns[1]->stmt;
                            ns[1]->stmt = NULL;
                        }else
                        {
                            stmt = NULL;
                        }

                        close_function(parser, stmt);
                        return NULL;
                :}
                ;






params                :    namelist    ","    "..."        %action on_namelist_ellipsis
                {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t    *ret;
                        AR_ASSERT(nodes != NULL && count == 3);
                        ns[0]->params->is_variadic = true;
                        ret = ns[0];
                        ns[0] = NULL;
                        return ret;
                :}
                |    namelist        %action    auto_return_0
                {:
                        psrNode_t *ret = nodes[0];
                        ret  = nodes[0];
                        nodes[0] = NULL;
                        return ret;
                :}
                |    "..."            %action    on_ellipsis
                {:
                        tguParams_t    *params;
                        tguSynNode_t    *ret;
                        AR_ASSERT(nodes != NULL && count == 1);

                        params = TGU_CreateParams();
                        params->is_variadic = true;
                        ret = __create_synnode(TGU_NODE_PARAMS_T, (void*)params);
                        return ret;
                :}

                |    .            %action    NULL
                ;



namelist            :    namelist    "," NAME        %action    on_name_list
                {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t    *ret;
                        tguParams_t    *params;
                        tguToken_t    tok;
                        AR_ASSERT(nodes != NULL && count == 2);
                        tok = ns[1]->token;
                        params = ns[0]->params;
                        TGU_InsertToParams(params, &tok);
                        ret = ns[0];
                        ns[0] = NULL;
                        return ret;
                :}

                |    NAME                    %action    on_name
                {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t    *ret;
                        tguParams_t    *params;
                        tguToken_t    tok;
                        AR_ASSERT(nodes != NULL && count == 1);
                        tok = ns[0]->token;
                        params = TGU_CreateParams();
                        TGU_InsertToParams(params, &tok);
                        ret = __create_synnode(TGU_NODE_PARAMS_T, (void*)params);
                        return ret;
                :}
                ;








/*************************************声明语句***************************************************/


declaration                :    "var"        init_declarator_list     semi            %action    auto_return_null
                    |    "var"        error                ";"            %action    auto_return_null
                    ;



init_declarator_list            :    init_declarator                        %action    auto_return_null
                    |    init_declarator_list "," init_declarator            %action    auto_return_null
                    ;



%code    handle_init_declarator{:
    
    static void    handle_symb_from_expression(tguParser_t     *parser, const tguToken_t *tok, tguExpr_t *expr)
    {
            tguSymb_t    *symb;
            size_t        t;
            AR_ASSERT(parser != NULL && tok != NULL);
            
            for(t = TGU_SYMB_VAR_T, symb = NULL; t <= TGU_SYMB_BLOCK_T && symb == NULL; ++t)
            {
                symb = TGU_FindSymbFromBlock(parser->top_block, tok->token, (tguSymbType_t)t, true);
            }


            
            if(symb)
            {
                wchar_t    msg[1024];
                parser->has_error = true;
                AR_swprintf(msg, 1024, L"error : '%ls' : redefinition",  tok->token);
                TGU_ReportError(&parser->report, msg, tok->lex_info.linenum);
            }else
            {
                tguStmt_t    *decl_stmt;
                symb = TGU_CreateSymb(TGU_SYMB_VAR_T, tok->token);
                symb->lex_info = tok->lex_info;
                TGU_InsertSymbToBlock(parser->top_block, symb);
                
                decl_stmt = TGU_CreateStmt(TGU_STT_DECL);
                decl_stmt->decl_stmt.id = symb;
                decl_stmt->decl_stmt.init_expr = expr;
                
                TGU_InsertStmtToBlock(parser->top_block, decl_stmt);
                
            }
    }
:};




init_declarator            :    NAME    "="     expression                %action    on_declarator
                    |    NAME                            %action    on_declarator
                    ;






aggregate_constructor        :    table_constructor
                    |    list_constructor
                    ;



list_constructor            :    "L"        "{"    list_field_list     optional_dot    "}"
                    |    "L"        "{"    "}"
                    |    "L"        "{"    error "}"
                    ;




list_field_list             :    list_field_list  "," expression         
                    |    expression                         
                    ;






table_constructor            :    "D"        "{"    table_field_list optional_dot    "}"        %action    on_table_constructor
                    |    "D"        "{"    "}"                %action    on_table_constructor
                    |    "D"        "{" error "}"                %action    on_table_constructor
                    ;


table_field_list             :    table_field_list ","        table_field
                    |    table_field
                    ;


table_field                :    expression    ":"    expression
                    ;


optional_dot                :    ","
                    |    .
                    ;

/*************************************语句***************************************************/


statement                :    compound_statement            %action    auto_return_0
                    |    expression_statement            %action    auto_return_0
                    |    selection_statement            %action    auto_return_0
                    |    iteration_statement            %action    auto_return_0
                    |    jump_statement            %action    auto_return_0
                    |    empty_statement            %action    auto_return_0
                    ;









/**************************************compound_statement*****************************/


%code {:
    tguStmt_t*        make_compound_stmt(tguParser_t     *parser, tguBlock_t        *block, const tguLexInfo_t *start, const tguLexInfo_t *end)
    {
            tguStmt_t    *ret;
            AR_ASSERT(parser != NULL);
            ret = TGU_CreateStmt(TGU_STT_COMPOUND);
            ret->lex_info = *start;
            

            if(block)
            {
                block->begin = *start;
                block->end = *end;
            }
            ret->compound_stmt.block = block;
            return ret;

    }
:};



compound_statement        :    start_block    compound_element_list        "}"        %action    on_compound_statement
                {:
                    tguParser_t     *parser = (tguParser_t*)ctx;
                    tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                    tguSynNode_t    *ret;
                    tguBlock_t        *cb = NULL;
                    tguStmt_t *stmt;
                        
                    AR_ASSERT(nodes != NULL && (count == 3));
                    cb = TGU_ParserPopBlock(parser);
                        
                    stmt = make_compound_stmt(parser, cb, &ns[0]->token.lex_info,&ns[2]->token.lex_info);
                    ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
                    return ret;
                :}

                |    start_block                        "}"        %action    on_empty_compound_statement
                {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t    *ret;
                        tguStmt_t *stmt;        
                        tguBlock_t        *cb = NULL;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        AR_ASSERT(nodes != NULL && (count == 2));
                        cb = TGU_ParserPopBlock(parser);
                        cb->begin = ns[0]->token.lex_info;
                        cb->end = ns[1]->token.lex_info;
                        
                        stmt = make_compound_stmt(parser, cb, &ns[0]->token.lex_info,&ns[1]->token.lex_info);
                        ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
                        return ret;
                        
                :}

                |    start_block      error                  "}"        %action    on_compound_error_statement
                {:
                        tguParser_t     *parser = (tguParser_t*)ctx;
                        /*tguSynNode_t    **ns = (tguSynNode_t**)nodes;*/
                        tguBlock_t        *cb = NULL;
                        AR_ASSERT(nodes != NULL && (count == 2));
                        AR_ASSERT(parser != NULL);
                        parser->has_error = true;
                        cb = TGU_ParserPopBlock(parser);
                        TGU_DestroyBlock(cb);
                        return NULL;
                :}
                ;



start_block            :    "{"        %action    on_start_block
                {:
                            tguParser_t     *parser = (tguParser_t*)ctx;
                            tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                            tguSynNode_t    *ret;
                            AR_ASSERT(ns != NULL && count == 1);
                            ret = ns[0]; 
                            ns[0] = NULL;
                            if(!parser->is_on_function_compound)
                            {
                                TGU_ParserPushBlock(parser);
                            }else
                            {
                                parser->is_on_function_compound = false;
                            }
                            return ret;
                :}
                ;








compound_element_list        :    compound_element_list        compound_element    %action    auto_return_null
                    |    compound_element                        %action    auto_return_null
                    {:
                        return NULL;
                    :}
                    ;
















compound_element        :    statement        %action    on_compound_element
                {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        AR_ASSERT(ns != NULL && count == 1);
                        if(ns[0] == NULL)
                        {
                            return NULL;
                        }
                        
                        AR_ASSERT(ns[0]->type == TGU_NODE_STMT_T && ns[0]->stmt != NULL);
                        TGU_InsertStmtToBlock(parser->top_block, ns[0]->stmt);
                        ns[0]->stmt = NULL;
                        return NULL;
                :}

                |    declaration        %action    auto_return_null
                ;










/*****************************************************************************/

%code {:
    static tguStmt_t*    make_empty_statement(tguParser_t *parser, const tguLexInfo_t *lex_info)
    {
            tguStmt_t    *ret;
            AR_ASSERT(parser != NULL && lex_info != NULL);
            ret = TGU_CreateStmt(TGU_STT_EMPTY);
            ret->lex_info = *lex_info;
            return ret;

    }



    static tguStmt_t*    make_expression_statement(tguParser_t *parser, tguExpr_t *expr, const tguLexInfo_t *lex_info)
    {
            tguStmt_t    *ret;
            AR_ASSERT(parser != NULL);
            ret = TGU_CreateStmt(TGU_STT_EXPR);

            if(lex_info)
            {
                ret->lex_info = *lex_info;
            }
            ret->expr = expr;
            return ret;

    }


        

:};


empty_statement            :    ";"        %action    on_empty_statement
                    {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        tguSynNode_t     *ret;
                        tguStmt_t        *stmt;
                        AR_ASSERT(ns != NULL && parser != NULL && count == 1);

                        stmt = make_empty_statement(parser, &ns[0]->token.lex_info);
                        ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
                        return ret;
                    :}
                    ;


expression_statement            :    expression     semi        %action on_expression_statement
                    {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        tguSynNode_t    *ret;
                        tguStmt_t    *stmt;
                        tguExpr_t    *expr;
                        AR_ASSERT(ns != NULL && count == 2);
                        
                        if(ns[0] == NULL)
                        {
                            expr = NULL;
                            parser->has_error = true;
                        }else
                        {
                            expr = ns[0]->expr;
                            ns[0]->expr = NULL;
                            AR_ASSERT(expr != NULL);
                        }
                            
                        stmt = make_expression_statement(parser, expr, expr ? &expr->lex_info : NULL);
                        ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
                        return ret;

                    :}
                    |    error    ";"            %action auto_return_null
                    ;





selection_statement            :    if_statement        %action auto_return_0
                    |    if_else_statement    %action auto_return_0
                    ;





%code    {:

    static tguStmt_t*    make_if_statement(tguParser_t *parser, tguExpr_t *cond, tguStmt_t *if_true, tguStmt_t *if_false, const tguLexInfo_t *lex_info)
    {
            tguStmt_t    *ret;
            AR_ASSERT(parser != NULL && lex_info != NULL);
            ret = TGU_CreateStmt(TGU_STT_IF);
            ret->lex_info = *lex_info;
            ret->if_stmt.expr = cond;
            ret->if_stmt.true_part = if_true;
            ret->if_stmt.false_part = if_false;
            return ret;

    }

:};


if_statement            :    "if" "(" expression ")" statement            %prec IF_WITHOUT_ELSE        %action on_if_statement
                |    "if" "(" error ")" statement            %prec IF_WITHOUT_ELSE        %action on_if_statement
                {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        tguSynNode_t    *ret;
                        tguExpr_t        *expr;
                        tguStmt_t        *if_true, *stmt;
                        AR_ASSERT(ns != NULL && count == 5);
                        
                        if(ns[2] == NULL)
                        {
                            expr = NULL;
                            parser->has_error = true;
                        }else
                        {
                            expr = ns[2]->expr;
                            ns[2]->expr = NULL;
                            AR_ASSERT(expr != NULL);
                        }
                            
                        if(ns[4] == NULL)
                        {    
                            if_true = NULL;
                            parser->has_error = true;
                        }else
                        {
                            if_true = ns[4]->stmt;
                            ns[4]->stmt = NULL;
                            AR_ASSERT(if_true != NULL);
                        }

                        stmt = make_if_statement(parser, expr, if_true, NULL, &ns[0]->token.lex_info);
                        ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
                        return ret;
                :}
                ;


if_else_statement        :    "if" "(" expression ")" statement "else" statement    %action on_if_else_statement
                |    "if" "(" error ")" statement "else" statement        %action on_if_else_statement
                {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        tguSynNode_t    *ret;
                        tguExpr_t        *expr;
                        tguStmt_t        *if_true;
                        tguStmt_t        *if_false;
                        tguStmt_t        *stmt;
                        AR_ASSERT(ns != NULL && count == 7);
                        if(ns[2] == NULL)
                        {
                            expr = NULL;
                            parser->has_error = true;
                        }else
                        {
                            expr = ns[2]->expr;
                            ns[2]->expr = NULL;
                            AR_ASSERT(expr != NULL);
                        }
                            
                        if(ns[4] == NULL)
                        {    
                            if_true = NULL;
                            parser->has_error = true;
                        }else
                        {
                            if_true = ns[4]->stmt;
                            ns[4]->stmt = NULL;
                            AR_ASSERT(if_true != NULL);
                        }

                        if(ns[6] == NULL)
                        {    
                            if_false = NULL;
                            parser->has_error = true;
                        }else
                        {
                            if_false = ns[6]->stmt;
                            ns[6]->stmt = NULL;
                            AR_ASSERT(if_false != NULL);
                        }


                        stmt = make_if_statement(parser, expr, if_true, if_false,  &ns[0]->token.lex_info);    
                        ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
                        return ret;
                :}
                ;




iteration_statement        :    while_statement            %action    auto_return_0
                |    do_while_statement            %action    auto_return_0
                |    for_statement                %action    auto_return_0
                ;






%code {:
    static tguStmt_t*    make_while_statement(tguParser_t *parser, tguStmtType_t type, tguExpr_t *cond, tguStmt_t *loop, const tguLexInfo_t *lex_info)
    {
            tguStmt_t    *ret;
            AR_ASSERT(parser != NULL && lex_info != NULL);
            ret = TGU_CreateStmt(type);
            ret->lex_info = *lex_info;
            ret->while_stmt.expr = cond;
            ret->while_stmt.loop_part = loop;
            return ret;

    }
:}
;






while_statement            :    "while" enter_loop  "(" expression ")" statement leave_loop    %action    on_while_statement
                    |    "while" enter_loop  "(" error ")" statement leave_loop        %action    on_while_statement
                    {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        tguSynNode_t    *ret;
                        tguExpr_t        *expr;
                        tguStmt_t        *stmt;
                        AR_ASSERT(ns != NULL && count == 7);

                        if(ns[3] == NULL)
                        {
                            expr = NULL;
                            parser->has_error = true;
                        }else
                        {
                            expr = ns[3]->expr;
                            ns[3]->expr = NULL;
                            AR_ASSERT(expr != NULL);
                        }
                            
                        if(ns[5] == NULL)
                        {    
                            stmt = NULL;
                            parser->has_error = true;
                        }else
                        {
                            stmt = ns[5]->stmt;
                            ns[5]->stmt = NULL;
                            AR_ASSERT(stmt != NULL);
                        }

                        stmt = make_while_statement(parser, TGU_STT_WHILE, expr, stmt, &ns[0]->token.lex_info);
                        ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
                        return ret;
                    :}
                    ;





do_while_statement            :    "do" enter_loop statement "while" "(" expression ")" leave_loop     semi            %action    on_do_while_statement
                    |    "do" enter_loop statement "while" "(" error ")" leave_loop         semi            %action    on_do_while_statement
                    {:
                        tguSynNode_t    **ns =     (tguSynNode_t**)nodes;
                        tguParser_t    *parser =    (tguParser_t*)ctx;
                        tguSynNode_t    *ret;
                        tguExpr_t        *expr;
                        tguStmt_t        *stmt;
                        AR_ASSERT(ns != NULL && count == 9);
                        if(ns[2] == NULL)
                        {
                            stmt = NULL;
                            parser->has_error = true;
                        }else
                        {
                            stmt = ns[2]->stmt;
                            ns[2]->stmt = NULL;
                            AR_ASSERT(stmt != NULL);
                        }
                            
                        if(ns[5] == NULL)
                        {    
                            expr = NULL;
                            parser->has_error = true;
                        }else
                        {
                            expr = ns[5]->expr;
                            ns[5]->expr = NULL;
                            AR_ASSERT(expr != NULL);
                        }

                        stmt = make_while_statement(parser, TGU_STT_DO, expr, stmt, &ns[0]->token.lex_info);
                        ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
                        return ret;
                    :}
                    ;



for_statement            :    "for"    "("    for_in_expression    ")"     enter_loop  statement leave_loop    %action    on_for_statement
                {:
                        tguSynNode_t        **ns = (tguSynNode_t**)nodes;
                        tguParser_t        *parser = (tguParser_t*)ctx;
                        tguSynNode_t        *ret;
                        
                        AR_ASSERT(ns != NULL && count == 11);
                        
                        AR_UNUSED(parser);
                        AR_UNUSED(ns);

                        ret = NULL;

                        return ret;
                :}
                |    "for"    "("    error    ")"    enter_loop  statement leave_loop    %action    on_error_for_statement
                {:
                        tguSynNode_t        **ns = (tguSynNode_t**)nodes;
                        tguParser_t        *parser = (tguParser_t*)ctx;
                        tguSynNode_t        *ret;


                        AR_UNUSED(parser);
                        AR_UNUSED(ns);

                        ret = NULL;



                        return ret;
                :}
                ;

for_in_expression        :    NAME "in" expression    
                ;


enter_loop                :    .                    %action on_enter_loop
                    {:
                        tguParser_t    *parser = NULL;
                        AR_ASSERT(ctx != NULL);
                        parser = (tguParser_t*)ctx;
                        parser->loop_level++;
                        return NULL;
                    :}
                    ;






leave_loop                :    .                    %action on_leave_loop
                    {:
                        tguParser_t    *parser = NULL;
                        AR_ASSERT(ctx != NULL);
                        parser = (tguParser_t*)ctx;
                        AR_ASSERT(parser->loop_level > 0);
                        parser->loop_level--;
                        return NULL;
                    :}
                    ;






%code{:
    static tguStmt_t*    make_jump_statement(tguParser_t *parser, tguStmtType_t type, tguExpr_t *expr, const tguLexInfo_t *lex_info)
    {
        tguStmt_t    *ret;
        wchar_t    msg[512];
        AR_ASSERT(parser != NULL && lex_info != NULL);
        
        ret = TGU_CreateStmt(type);
        ret->lex_info = *lex_info;

        if(type == TGU_STT_RETURN)
        {
            ret->return_stmt.expr = expr;
            
        }else
        {

            if(parser->loop_level == 0)
            {
                const wchar_t *err_msg = NULL;
                if(type == TGU_STT_CONTINUE)
                {
                    err_msg = L"error : illegal continue";
                }else if(type == TGU_STT_BREAK)
                {
                    err_msg =  L"error : illegal break";
                }
            
                if(err_msg)
                {
                    parser->has_error = true;
                    AR_swprintf(msg, 512, L"%ls", err_msg);
                    TGU_ReportError(&parser->report, msg, ret->lex_info.linenum);
                }
            }
        }


        return ret;
    }
:}
;


jump_statement            :    "continue"     semi                %action on_continue_statement
                    {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t     *ret;
                        tguStmt_t        *stmt;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        stmt = make_jump_statement(parser, TGU_STT_CONTINUE,     NULL, &ns[0]->token.lex_info);
                        ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
                        return ret;

                    :}

                    |    "break"     semi                %action on_break_statement
                    {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t     *ret;
                        tguStmt_t        *stmt;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        ret = AR_NEW(tguSynNode_t);
                        ret->type = TGU_NODE_STMT_T;
                        stmt = make_jump_statement(parser, TGU_STT_BREAK,     NULL, &ns[0]->token.lex_info);
                        ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
                        return ret;
                        
                    :}

                    |    "return"     semi                %action on_return_statement
                    |    "return"     expression semi        %action on_return_statement
                    {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t     *ret;
                        tguExpr_t        *expr;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        tguStmt_t        *stmt;
                        AR_ASSERT(nodes != NULL && (count == 2 || count == 3));
                        
                        if(count == 2)
                        {
                            expr = NULL;
                        }else
                        {
                            if(ns[1] == NULL)
                            {
                                expr = NULL;
                                parser->has_error = true;
                            }else
                            {
                                AR_ASSERT(ns[1]->type == TGU_NODE_EXPR_T);
                                expr = ns[1]->expr;
                                ns[1]->expr = NULL;
                                AR_ASSERT(expr != NULL);
                            }
                        }

                        stmt = make_jump_statement(parser, TGU_STT_RETURN,     expr, &ns[0]->token.lex_info);
                        ret = __create_synnode(TGU_NODE_STMT_T, (void*)stmt);
                        return ret;
                    :}
                    ;




semi                    :    ";"                                %action    auto_return_0
                    |    error                                %action    on_semi_error
                    {:
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        AR_ASSERT(parser != NULL);
                        parser->has_error = true;
                        return NULL;
                    :}
                    ;


/*****************************************表达式*********************************************/


expression                :    assignment_expression        %action auto_return_0
                    ;



%code {:

    static tguExpr_t*        make_assignment_expression(tguParser_t    *parser,     tguExpr_t *addr, tguExpr_t *value, const tguLexInfo_t *lex_info)
    {
            tguExpr_t    *ret;
            wchar_t    msg[512];
            AR_ASSERT(parser != NULL && lex_info != NULL);
            ret = TGU_CreateExpr(TGU_ET_ASSIGN);

            if(addr)
            {
                if(!addr->is_lvalue)
                {
                    parser->has_error = true;
                    AR_swprintf(msg, 512, L"%ls", L"error  : left operand must be l-value");
                    TGU_ReportError(&parser->report, msg, addr->lex_info.linenum);
                }else
                {
                    AR_ASSERT(!addr->is_constant);
                }
            }

            ret->is_lvalue = true;
            ret->is_constant = true;
            ret->lex_info = *lex_info;

            ret->assign_expr.addr = addr;
            ret->assign_expr.value = value;

            return ret;
    }

:}
;



assignment_expression        :    constant_expression                        %action     auto_return_0
                    |    unary_expression    "="    assignment_expression    %action    on_assignment_expression
                    {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t     *ret;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        tguExpr_t        *addr, *value, *expr;
                        const tguLexInfo_t *lex_info; 
                        AR_ASSERT(ns != NULL && count == 3 && parser != NULL);

                        if(ns[0] == NULL)
                        {
                            parser->has_error = true;
                            addr = NULL;    
                        }else
                        {
                            addr = ns[0]->expr;
                            ns[0]->expr = NULL;
                            AR_ASSERT(addr != NULL);
                        }
                        

                        if(ns[2] == NULL)
                        {
                            parser->has_error = true;
                            value = NULL;    
                        }else
                        {
                            value = ns[2]->expr;
                            ns[2]->expr = NULL;
                            AR_ASSERT(value != NULL);
                        }

                        lex_info = addr != NULL ? &addr->lex_info : &ns[1]->token.lex_info;
                        AR_ASSERT(lex_info != NULL);
                        expr = make_assignment_expression(parser, addr, value, lex_info);
                        ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);

                        return ret;

                    :}
                    ;




%code {:

    static tguExpr_t*        make_condition_expression(tguParser_t    *parser,     tguExpr_t *cond, tguExpr_t *if_true, tguExpr_t *if_false, const tguLexInfo_t *lex_info)
    {
            tguExpr_t    *ret;
            AR_ASSERT(parser != NULL && lex_info != NULL);
            ret = TGU_CreateExpr(TGU_ET_CONDITIONAL);

            ret->is_lvalue = true;
            ret->is_constant = false;
            if(if_true)
            {
                if(!if_true->is_lvalue)
                {
                    ret->is_lvalue = false;
                }

                if(if_true->is_constant)
                {
                    ret->is_constant = true;
                }
            }

            if(if_false)
            {
                if(!if_false->is_lvalue)
                {
                    ret->is_lvalue = false;
                }
                
                if(if_false->is_constant)
                {
                    ret->is_constant = true;
                }
            }

            ret->lex_info = *lex_info;

            ret->cond_expr.cond = cond;
            ret->cond_expr.if_true  = if_true;
            ret->cond_expr.if_false = if_false;
            return ret;

    }

:}
;







constant_expression            :    binary_expression                                    %action     auto_return_0
                    |    binary_expression    "?"    expression    ":"        expression        %action    on_condition_expression
                    {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t     *ret;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        tguExpr_t        *cond, *if_true, *if_false, *expr;
                        const tguLexInfo_t *lex_info;
                        AR_ASSERT(ns != NULL && count == 3 && parser != NULL);

                        if(ns[0] == NULL)
                        {
                            parser->has_error = true;
                            cond= NULL;    
                        }else
                        {
                            cond = ns[0]->expr;
                            ns[0]->expr = NULL;
                            AR_ASSERT(cond != NULL);
                        }

                        

                        if(ns[2] == NULL)
                        {
                            parser->has_error = true;
                            if_true = NULL;    
                        }else
                        {
                            if_true= ns[2]->expr;
                            ns[2]->expr = NULL;
                            AR_ASSERT(if_true != NULL);
                        }
                        
                        if(ns[4] == NULL)
                        {
                            parser->has_error = true;
                            if_false = NULL;    
                        }else
                        {
                            if_false= ns[4]->expr;
                            ns[4]->expr = NULL;
                            AR_ASSERT(if_false != NULL);
                        }

                        lex_info = cond != NULL ? &cond->lex_info : &ns[1]->token.lex_info;
                        AR_ASSERT(lex_info != NULL);
                        expr = make_condition_expression(parser, cond, if_true, if_false, lex_info);
                        ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
                        return ret;

                    :}
                    ;





%code {:

    static tguExpr_t*        make_binary_expression(tguParser_t    *parser,     tguExprOP_t op, tguExpr_t *left, tguExpr_t *right, const tguLexInfo_t *lex_info)
    {
            tguExpr_t    *ret;    
            AR_ASSERT(parser != NULL && lex_info != NULL);
            ret = TGU_CreateExpr(TGU_ET_BINARY);
            ret->is_lvalue = false;
            ret->is_constant = false;
            ret->lex_info = *lex_info;
            ret->binary_expr.op = op;
            ret->binary_expr.left  = left;
            ret->binary_expr.right = right;
            return ret;
    }

:}
;

binary_expression            :    unary_expression                        %action     auto_return_0
                    |    binary_expression    "+"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "-"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "*"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "/"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "%"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "<"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "<="    binary_expression        %action    on_binary_expression
                    |    binary_expression    ">"    binary_expression        %action    on_binary_expression
                    |    binary_expression    ">="    binary_expression        %action    on_binary_expression
                    |    binary_expression    "=="    binary_expression        %action    on_binary_expression
                    |    binary_expression    "!="    binary_expression        %action    on_binary_expression
                    |    binary_expression    "&&"    binary_expression        %action    on_binary_expression
                    |    binary_expression    "||"    binary_expression        %action    on_binary_expression
                    {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t     *ret;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        tguExpr_t        *left, *right, *expr;

                        tguExprOP_t    op;
                        const tguLexInfo_t *lex_info;
                        tguToken_t    tok;
                        AR_ASSERT(ns != NULL && count == 3 && parser != NULL);

                        if(ns[0] == NULL)
                        {
                            parser->has_error = true;
                            left = NULL;    
                        }else
                        {
                            left = ns[0]->expr;
                            ns[0]->expr = NULL;
                            AR_ASSERT(left != NULL);
                        }

                        AR_ASSERT(ns[1] != NULL);
                        tok = ns[1]->token;


                        if(ns[2] == NULL)
                        {
                            parser->has_error = true;
                            right = NULL;    
                        }else
                        {
                            right = ns[2]->expr;
                            ns[2]->expr = NULL;
                            AR_ASSERT(right != NULL);
                        }

                        switch(tok.term_val)
                        {
                        case TOK_INC:
                            op = TGU_OP_PLUS;
                            break;
                        case TOK_SUB :
                            op = TGU_OP_MINUS;
                            break;
                        case TOK_MUL:
                            op = TGU_OP_MUL;
                            break;
                        case TOK_DIV:
                            op = TGU_OP_DIV;
                            break;
                        case TOK_MOD:
                            op = TGU_OP_MOD;
                            break;
                        case TOK_LESS:
                            op = TGU_OP_LESS;
                            break;
                        case TOK_LE:
                            op = TGU_OP_LESS_OR_EQUAL;
                            break;
                        case TOK_GREATER:
                            op = TGU_OP_GREATER;
                            break;
                        case TOK_GE:
                            op = TGU_OP_GREATER_OR_EQUAL;
                            break;
                        case TOK_EQ:
                            op = TGU_OP_IS_EQUAL;
                            break;
                        case TOK_NE:
                            op = TGU_OP_NOT_EQUAL;
                            break;
                        case TOK_ANDAND:
                            op = TGU_OP_LOGICAL_AND;
                            break;
                        case TOK_OROR:
                            op = TGU_OP_LOGICAL_OR;
                            break;
                        default:
                            op = TGU_OP_NONE;/*op如果在此不赋值会导致一个warning*/
                            AR_ASSERT(false);
                            break;
                        }

                        lex_info  = left != NULL ? &left->lex_info : &tok.lex_info;
                        AR_ASSERT(lex_info != NULL);
                        expr = make_binary_expression(parser, op, left, right, lex_info);
                        ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
                        return ret;
                    :}
                    ;


%code {:

    static tguExpr_t*        make_unary_expression(tguParser_t    *parser,     tguExprOP_t op, tguExpr_t *expr, bool_t is_lvalue, const tguLexInfo_t *lex_info)
    {
            tguExpr_t    *ret;
            wchar_t     msg[512];
            const         wchar_t *op_str;
            AR_ASSERT(parser != NULL && lex_info != NULL);
            
            ret = TGU_CreateExpr(TGU_ET_UNARY);
            ret->is_lvalue = is_lvalue;
            ret->lex_info = *lex_info;
            ret->unary_expr.op = op;
            ret->unary_expr.expr = expr;
            ret->is_constant = expr == NULL ? false : expr->is_constant;
            
            switch(op)
            {
            case TGU_OP_PREINC:
            case TGU_OP_POSTINC:
                op_str = L"++";
                break;
            case TGU_OP_PREDEC:
            case TGU_OP_POSTDEC:
                op_str = L"--";
                break;
            default:
                op_str = NULL;
                break;
            }

            if(op_str != NULL && !ret->is_lvalue)
            {
                parser->has_error = true;
                AR_swprintf(msg, 512, L"error : '%ls' needs l-value", op_str);
                TGU_ReportError(&parser->report, msg, lex_info->linenum);

            }
            
            return ret;
    }



    static tguExpr_t*    make_index_expression(tguParser_t *parser, tguExpr_t *expr, tguExpr_t *index_expr, const tguLexInfo_t *lex_info)
    {
        tguExpr_t    *ret;
        wchar_t msg[512];

        AR_ASSERT(parser != NULL && lex_info != NULL);

        if(expr != NULL)
        {
            if(expr->is_constant)
            {
                parser->has_error = true;
                AR_swprintf(msg, 512, L"%ls", L"error : invalid table action");
                TGU_ReportError(&parser->report, msg, lex_info->linenum);
            }
        }
        
        ret = TGU_CreateExpr(TGU_ET_INDEX);
        ret->index_expr.expr = expr;
        ret->index_expr.index_expr = index_expr;
        ret->is_lvalue = expr == NULL ? true : expr->is_lvalue;
        ret->is_constant = false;
        ret->lex_info = *lex_info;

        return ret;
    }

    
:}
;


%code handle_constant {:
    static tguExpr_t*        make_constant_expression(tguParser_t    *parser, tguToken_t *token)
    {
            tguSymb_t        *symb;
            tguSymbTbl_t        *symb_tbl;
            tguExpr_t        *expr;
            AR_ASSERT(parser != NULL && token != NULL); 
            
            expr = NULL;
            symb = NULL;
            symb_tbl = parser->ext->global_constant;
            AR_ASSERT(symb_tbl != NULL);

            switch(token->term_val)
            {
            default:
                AR_ASSERT(false);
                break;
            case TOK_NULL:
                symb = TGU_InstallNull(symb_tbl);
                break;
            case TOK_TRUE:
                symb = TGU_InstallBoolean(symb_tbl, true);
                break;
            case TOK_FALSE:
                symb = TGU_InstallBoolean(symb_tbl, false);
                break;
            case TOK_FLOAT_NUMBER:
            {
                double df;
                AR_wtod(token->token, &df);
                symb = TGU_InstallFloat(symb_tbl, df); 
            }
                break;
            case TOK_INT_NUMBER:
            {
                int_64_t    num;
                AR_wtoi64(token->token, &num, 0);/*0表示AR_wtoi64自动识别*/
                symb = TGU_InstallInt(symb_tbl, num); 
            }
                break;
            case TOK_STRING:
                symb = TGU_InstallString(symb_tbl, token->token);
                break;
            }
            
            expr = TGU_CreateExpr(TGU_ET_SYMBOL);
            expr->is_lvalue = false;
            expr->is_constant = true;
            expr->lex_info = token->lex_info;
            expr->symb = symb;
            return expr;
    }

:}
;

%code handle_identifier{:
    
    static tguExpr_t*        make_identifier_expression(tguParser_t    *parser, tguToken_t *token)
    {
            tguExpr_t    *expr;
            tguSymb_t    *symb;
            size_t        t;
            AR_ASSERT(parser != NULL && token != NULL);
            AR_ASSERT(parser->top_block != NULL);
            
            
            for(t = TGU_SYMB_VAR_T, symb = NULL; t <= TGU_SYMB_BLOCK_T && symb == NULL; ++t)
            {
                symb = TGU_FindSymbFromBlock(parser->top_block, token->token, (tguSymbType_t)t, false);
            }


            if(symb == NULL)
            {
                for(t = TGU_SYMB_VAR_T, symb = NULL; t <= TGU_SYMB_BLOCK_T && symb == NULL; ++t)
                {
                        symb = TGU_FindSymb((tguSymbTbl_t*)parser->ext->build_in, token->token, (tguSymbType_t)t);
                }
            }
                
            if(symb == NULL)
            {
                wchar_t msg[512];
                expr = TGU_CreateExpr(TGU_ET_UNDEF_NAME);
                expr->name = token->token;
                parser->has_error = true;
                AR_swprintf(msg, 512, L"error : '%ls' : undeclared identifier", token->token);
                TGU_ReportError(&parser->report, msg, token->lex_info.linenum);
                
            }else
            {
                expr = TGU_CreateExpr(TGU_ET_SYMBOL);
                expr->symb = symb;
            }
            
            if(symb && symb->type == TGU_SYMB_VAR_T)
            {
                expr->is_lvalue = true;
            }else
            {
                    expr->is_lvalue  = false;
            }

            expr->is_constant = false;
            expr->lex_info = token->lex_info;
            return expr;
    }




:}
;



unary_expression        :    "+"    unary_expression    %action    on_unary_expression
                |    "-"    unary_expression    %action    on_unary_expression
                |    "!"    unary_expression    %action    on_unary_expression
                |    "++"     unary_expression    %action    on_unary_expression
                |    "--"    unary_expression    %action    on_unary_expression
                {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t     *ret;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        tguExpr_t        *expr;

                        tguExprOP_t        op;
                        tguToken_t        tok;
                        const tguLexInfo_t    *lex_info;
                        bool_t            is_lvalue;
                        AR_ASSERT(ns != NULL && count == 2 && parser != NULL);
            
                        if(ns[1] == NULL)
                        {
                            parser->has_error = true;
                            expr = NULL;    
                        }else
                        {
                            expr = ns[1]->expr;
                            ns[1]->expr = NULL;
                            AR_ASSERT(expr != NULL);
                        }

                        AR_ASSERT(ns[0] != NULL);
                        tok = ns[0]->token;    
                        
                        switch(tok.term_val)
                        {
                        case TOK_INC:
                            op = TGU_OP_PREINC;
                            is_lvalue = true;
                            break;
                        case TOK_DEC:
                            op = TGU_OP_PREDEC;
                            is_lvalue = true;
                            break;
                        case TOK_ADD:
                            op = TGU_OP_UNARY_PLUS;
                            is_lvalue = false;
                            break;
                        case TOK_SUB:
                            op = TGU_OP_UNARY_MINUS;
                            is_lvalue = false;
                            break;
                        case TOK_NOT:
                            op = TGU_OP_LOGICAL_NOT;
                            is_lvalue = false;
                            break;
                        default:
                            op = TGU_OP_NONE;
                            is_lvalue = false;
                            AR_ASSERT(false);
                            break;
                        }
                        lex_info = expr != NULL ? &expr->lex_info : &tok.lex_info;
                        expr = make_unary_expression(parser, op, expr, is_lvalue, lex_info);
                        ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
                        return ret;

                :}

                |    postfix_expression        %action     auto_return_0
                ;



postfix_expression        :    postfix_expression    "++"        %action    on_post_add_minus_expression
                |    postfix_expression    "--"        %action    on_post_add_minus_expression
                {:
                        tguSynNode_t        **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t         *ret;
                        tguParser_t        *parser = (tguParser_t*)ctx;
                        tguExpr_t        *expr;
                        tguToken_t        tok;
                        tguExprOP_t        op;
                        const tguLexInfo_t    *lex_info; 

                        AR_ASSERT(ns != NULL && count == 2 && parser != NULL);

                        if(ns[0] == NULL)
                        {
                            parser->has_error = true;
                            expr = NULL;    
                        }else
                        {
                            expr = ns[0]->expr;
                            ns[0]->expr = NULL;
                            AR_ASSERT(expr != NULL);
                        }

                        AR_ASSERT(ns[1] != NULL );
                        tok = ns[1]->token;    
                            
                        switch(tok.term_val)    
                        {
                        case TOK_INC:
                            op = TGU_OP_POSTINC;
                            break;
                        case TOK_DEC:
                            op = TGU_OP_POSTDEC;
                            break;
                        default:
                            op = TGU_OP_NONE;
                            AR_ASSERT(false);
                            break;
                        }
                        
                        lex_info = expr != NULL ? &expr->lex_info : &tok.lex_info;
                        expr = make_unary_expression(parser, op, expr, false, lex_info);
                        ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
                        return ret;
                :}

                |    postfix_expression "[" expression "]"        %action    on_index_expression
                |    postfix_expression "[" error "]"            %action    on_index_expression
                {:
                    
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t     *ret;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        tguExpr_t        *expr, *index_expr;
                        const tguLexInfo_t    *lex_info;
                        AR_ASSERT(ns != NULL && count == 4 && parser != NULL);

                        if(ns[0] == NULL)
                        {
                            parser->has_error = true;
                            expr = NULL;
                        }else
                        {
                            expr = ns[0]->expr;
                            ns[0]->expr = NULL;
                            AR_ASSERT(expr != NULL);
                        }

                        if(ns[2] == NULL)
                        {
                            index_expr = NULL;
                            parser->has_error = true;
                        }else
                        {
                            index_expr = ns[2]->expr;
                            ns[2]->expr = NULL;
                            AR_ASSERT(index_expr != NULL);
                        }

                        lex_info = expr != NULL ? &expr->lex_info : &ns[1]->token.lex_info;
                        expr = make_index_expression(parser, expr, index_expr, lex_info);
                        ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
                        return ret;
                :}
                |    postfix_expression     "."    NAME    %action    on_access_name_expression
                {:
                        tguSynNode_t        **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t        *ret;
                        tguParser_t        *parser = (tguParser_t*)ctx;
                        tguExpr_t        *expr, *index_expr;
                        tguToken_t        tmp;
                        const tguLexInfo_t    *lex_info;
                        AR_ASSERT(ns != NULL && count == 3 && parser != NULL);

                        if(ns[0] == NULL)
                        {
                            parser->has_error = true;
                            expr = NULL;
                        }else
                        {
                            expr = ns[0]->expr;
                            ns[0]->expr = NULL;
                            AR_ASSERT(expr != NULL);
                        }

                        tmp = ns[2]->token;
                        tmp.term_val = TOK_STRING;
                        tmp.token = ns[2]->token.token;
                        index_expr = make_constant_expression(parser, &tmp);
                        AR_ASSERT(index_expr != NULL);
                        tmp.token = NULL;

                        lex_info = expr != NULL ? &expr->lex_info : &index_expr->lex_info;
                        expr = make_index_expression(parser, expr, index_expr, lex_info);
                        ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
                        return ret;
                :}
                |    call_expression                %action auto_return_0
                |    primary_expression                %action auto_return_0
                ;    
                




primary_expression        :    "(" expression")"                            %action    on_lp_rp_expression
                |    "(" error ")"                                %action    on_lp_rp_expression
                {:
                    tguParser_t    *parser = (tguParser_t*)ctx;
                    psrNode_t     *ret;
                    if(nodes[1] == NULL)
                    {
                        parser->has_error = true;
                        ret = NULL;
                    }else
                    {
                        ret = nodes[1];
                        nodes[1] = NULL;
                    }
                    return ret;
                :}

                |    NAME                                        %action    on_identifier_expression
                {:
                        tguSynNode_t        **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t         *ret;
                        tguParser_t        *parser = (tguParser_t*)ctx;
                        tguExpr_t        *expr;
                        AR_ASSERT(parser != NULL && ns != NULL && count == 1);
                        expr = make_identifier_expression(parser, &ns[0]->token);
                        
                        ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
                        return ret;

                :}
                |    constant            %action    auto_return_0
                |    aggregate_constructor    %action    auto_return_0
                |    import_expression        %action    auto_return_0
                ;



/**************************************import_expression***********************************************/

constant            :    FLOAT_NUMBER            %action    on_constant
                |    INT_NUMBER            %action    on_constant
                |    STRING                %action    on_constant
                |    "true"                %action    on_constant
                |    "false"            %action    on_constant
                |    "null"                %action    on_constant
                ;



import_expression        :    "import"    "(" STRING             ")"            %action    on_import_statement
                |    "import"    "(" STRING "," STRING    ")"            %action    on_import_statement
                {:
                    return NULL;
                :}
                ;



/*辅助函数*/
%code {:
    static tguExpr_t*        make_call_expression(tguParser_t    *parser, tguExpr_t *call_expr, tguExpr_t *args, const tguLexInfo_t *lex_info)
    {
            tguExpr_t *expr;
            AR_ASSERT(parser != NULL && lex_info != NULL);

            expr = TGU_CreateExpr(TGU_ET_FUNC_CALL);
            expr->is_lvalue = false;
            expr->is_constant = false;
            expr->lex_info = *lex_info;
            
            expr->func_call_expr.func_call = call_expr;
            expr->func_call_expr.arg_list = args;

            return expr;
    }
:}
;



call_expression        :    postfix_expression "(" expression_list ")"        %action    on_call_expression
                |    postfix_expression "(" error ")"                %action    on_call_expression
                |    postfix_expression "("     ")"                %action    on_call_expression
                {:
                        tguSynNode_t        **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t         *ret;
                        tguParser_t    *parser = (tguParser_t*)ctx;
                        tguExpr_t        *expr, *call_expr, *args;
                        const tguLexInfo_t    *lex_info;

                        /*如果postfix_expression 为空，则表明此call表达式错误*/
                        if(ns[0] == NULL)                
                        {
                            parser->has_error = true;
                            call_expr = NULL;
                        }else
                        {
                            call_expr= ns[0]->expr;
                            ns[0]->expr = NULL;
                        }


                        if(count == 4)
                        {
                            if(ns[2] == NULL)/*对应"(" error ")"*/
                            {
                                args = NULL;
                                parser->has_error = true;
                            }else
                            {
                                args = ns[2]->expr;
                                ns[2]->expr = NULL;
                                AR_ASSERT(args != NULL);
                            }
                        }else
                        {
                        
                            AR_ASSERT(count == 3);
                            args = NULL;
                        }
                        
                        lex_info = call_expr != NULL ? &call_expr->lex_info : &ns[1]->token.lex_info;
                        expr = make_call_expression(parser, call_expr, args, lex_info );
                        
                        ret = __create_synnode(TGU_NODE_EXPR_T, (void*)expr);
                        return ret;
                :}
                ;







expression_list        :    expression                    %action    auto_return_0
                |    expression_list "," expression        %action    on_expression_list
                {:
                        tguSynNode_t    **ns = (tguSynNode_t**)nodes;
                        tguSynNode_t    *ret;
                        tguExpr_t        *lst;
                        AR_ASSERT(ns != NULL && count == 3);
                        if(ns[0] == NULL) return ns[2];
                        if(ns[2] == NULL) return ns[0];
                        AR_ASSERT(ns[0]->expr != NULL  && ns[2]->expr != NULL);

                        for(lst = ns[0]->expr; lst->next != NULL; lst = lst->next);
                        
                        lst->next = ns[2]->expr;
                        ns[2]->expr = NULL;
                        ret = ns[0];
                        ns[0] = NULL;
                        return ret;
                :}
                ;















