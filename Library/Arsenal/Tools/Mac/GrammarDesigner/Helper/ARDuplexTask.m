/* * Copyright (c) 2011 by Solidus * This file is part of Arsenal library tools source code. * * Permission to use, copy, modify, distribute and sell this software * and its documentation for any purpose is hereby granted without fee, * provided that the above copyright notice appear in all copies and * that both that copyright notice and this permission notice appear * in supporting documentation.It is provided "as is" without express  * or implied warranty. * */#import "ARThread.h"/**************************************ARDuplexTaskMessage**************************/@implementation ARDuplexTaskMessage : NSObject@synthesize name;-(id)init{		self = [self initWithName : nil];				return self;}-(void)dealloc{		[name release];		[super dealloc];}-(id)initWithName : (NSString*)n;{		self = [super init];		if(self)		{				[n retain];				name = n;		}		return self;}@end/**************************************ARDuplexTaskWorker DECL**************************/@interface ARDuplexTaskWorker : NSObject<NSMachPortDelegate>{		ARDuplexTask	*task;		BOOL			isDone;}@property (readwrite,assign) ARDuplexTask	*task;@property (readwrite,assign) BOOL			isDone;-(void)workerThread;-(void)handlePortMessage:(NSPortMessage *)portMessage;@end/**********************************************************************************************//**************************************ARDuplexTask**************************/@implementation ARDuplexTask-(NSMachPort*)getMainPort {		return mainPort;}-(NSMachPort*)getWorkerPort {		return workerPort;}-(void)handlePortMessage:(NSPortMessage *)portMessage{		DLog(@"On ARDuplexTask::handlePortMessage %@", portMessage);				while(![mainQueue isEmpty])		{				ARDuplexTaskMessage *msg = [mainQueue getData];								assert(msg != nil);								[delegate handleMainThreadMessage : msg 										  forTask : self				 ];		}}-(void)onWorkerThreadPortMessageNotify{		DLog(@"On ARDuplexTask::onWorkerThreadPortMessageNotify");				while(![workerQueue isEmpty])		{				ARDuplexTaskMessage *msg = [workerQueue getData];								assert(msg != nil);								[delegate handleWorkerThreadMessage : msg 										  forTask : self				 ];		}}-(id)init{		self = [super init];				if(self)		{				isStarted = NO;								mainQueue = [[ARAsyncQueue alloc] init];				workerQueue = [[ARAsyncQueue alloc] init];												mainPort = (NSMachPort*)[NSMachPort port];				[mainPort setDelegate : self];				[mainPort retain];								worker = [[ARDuplexTaskWorker alloc] init];				worker.isDone = YES;				worker.task = self;								workerPort = (NSMachPort*)[NSMachPort port];				[workerPort setDelegate : worker];				[workerPort retain];				DLog(@"Create ARDuplexTask mainPort == %d : workerPort == %d", [mainPort machPort], [workerPort machPort]);				}		return self;}-(void)dealloc{		[delegate release];		delegate = nil;				[mainPort release];		mainPort = nil;				[workerPort release];		workerPort = nil;				[workerThread release];		workerThread = nil;				while(![mainQueue isEmpty])		{				id data = [mainQueue getData];				[data release];		}		[mainQueue release];				while(![workerQueue isEmpty])		{				id data = [workerQueue getData];				[data release];		}		[workerQueue release];								[super dealloc];						}-(void)sendNotifyToWorker : (uint)msgid{		NSPortMessage *notify =	[ [NSPortMessage alloc] initWithSendPort: workerPort															   receivePort: mainPort																components:nil										 ];						if(notify)		{				[notify setMsgid:msgid];				[notify sendBeforeDate:[NSDate date]];				DLog(@"sendNotifyToWorker : %@", notify);		}				//DLog(@"notif retainCount == %d", [notify retainCount]);		[notify release];		}-(void)sendNotifyToMain : (uint)msgid{		NSPortMessage *notify = [[NSPortMessage alloc]  initWithSendPort : mainPort													 receivePort : workerPort													 components : nil								 ];				if(notify)		{				[notify setMsgid:msgid];				[notify sendBeforeDate:[NSDate date]];				DLog(@"sendNotifyToMain : %@", notify);		}				[notify release];}-(void)start{		assert(!isStarted && delegate != nil);				if(!isStarted && delegate != nil)		{								isStarted = YES;				worker.isDone = NO;				[[NSRunLoop currentRunLoop] addPort:mainPort forMode:NSDefaultRunLoopMode];								workerThread = [[ARThread alloc] initWithTarget : worker													   selector : @selector(workerThread)													   argument : nil								];						}}-(void)stop{		//assert(isStarted);				if(isStarted)		{				[self sendNotifyToWorker : AR_DUPLEX_TASK_MSGID_TO_WORKER_EXIT];				[workerThread join];				[workerThread release];				workerThread = nil;				[[NSRunLoop currentRunLoop] removePort:mainPort forMode:NSDefaultRunLoopMode];				isStarted = NO;					}}-(void)PostMsgToWorker	:		(ARDuplexTaskMessage*)msg{		assert(msg != nil);		if(isStarted)		{				[workerQueue putData : msg];						[self sendNotifyToWorker : AR_DUPLEX_TASK_MSGID_TO_WORKER];		}}-(void)PostMsgToMain	:		(ARDuplexTaskMessage*)msg{				assert(msg != nil);		if(isStarted)		{						[mainQueue putData : msg];				[self sendNotifyToMain : AR_DUPLEX_TASK_MSGID_TO_MAIN];		}}-(void)setDelegate : (NSObject<ARDuplexTaskDelegate>*)newDelegate{		[newDelegate retain];		[delegate release];		delegate = newDelegate;}-(NSObject<ARDuplexTaskDelegate>*) delegate{		return delegate;}@end/**************************************ARDuplexTaskWorker IMPL**************************/@implementation ARDuplexTaskWorker @synthesize task;@synthesize isDone;-(id)init{		self = [super init];				if(self)		{				isDone = NO;				task = nil;		}		return self;}-(void)dealloc{		DLog(@"ARDuplexTaskWorker::dealloc");		[super dealloc];}-(void)handlePortMessage:(NSPortMessage *)portMessage{		DLog(@"On ARDuplexTaskWorker::handlePortMessage %@", portMessage);				if([portMessage msgid] == AR_DUPLEX_TASK_MSGID_TO_WORKER_EXIT)		{				isDone = YES;		}				[task onWorkerThreadPortMessageNotify];		}-(void)workerThread{		assert(task != nil);				NSObject<ARDuplexTaskDelegate>	*taskDelegate = [task delegate];				[[NSRunLoop currentRunLoop] addPort:[task getWorkerPort] forMode:NSDefaultRunLoopMode];				[taskDelegate onWorkerBegin];								do{								[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode										 beforeDate:[NSDate distantFuture]				 ];		}while(!isDone);						[taskDelegate onWorkerEnd];						[[NSRunLoop currentRunLoop] removePort :[task getWorkerPort] forMode:NSDefaultRunLoopMode];						}@end