/* * Copyright (c) 2011 by Solidus * This file is part of Arsenal library tools source code. * * Permission to use, copy, modify, distribute and sell this software * and its documentation for any purpose is hereby granted without fee, * provided that the above copyright notice appear in all copies and * that both that copyright notice and this permission notice appear * in supporting documentation.It is provided "as is" without express  * or implied warranty. * */#import "ARThread.h"@interface ThreadData	: NSObject{		id				target;		SEL				action;		id				arg;		AREvent			*eventIsDone;		AREvent			*eventIsInitialized;}@property (readwrite, retain) id		target;@property (readwrite, assign) SEL		action;@property (readwrite, retain) id		arg;-(id)	init;-(void) dealloc;-(void) waitForInitialized;-(void) waitForDone;-(BOOL) waitForDoneTimeout : (NSTimeInterval) milliseconds;-(void) run;@end@implementation ThreadData@synthesize target;@synthesize action;@synthesize arg;-(id)	init{		self = [super init];				if(self)		{				eventIsDone				= [[AREvent alloc] initEvent : NO];				eventIsInitialized		= [[AREvent alloc] initEvent : NO];		}		return (self);}-(void) dealloc{		[target release];		action = nil;				[arg release];		[eventIsDone release];		[eventIsInitialized release];		[super dealloc];}-(void) waitForInitialized{		[eventIsInitialized wait];}-(void) waitForDone{		[eventIsDone wait];}-(BOOL) waitForDoneTimeout : (NSTimeInterval) milliseconds{		return [eventIsDone waitTimeout : milliseconds];}-(void) run{		[eventIsInitialized set];				@try{		if(target != nil && action != nil)		{				if(arg != nil)				{						[target performSelector : action withObject : arg];				}else				{						[target performSelector : action];				}		}		}@catch(NSException *e)		{				NSLog(@"exception occur in ARThread (%@ : %@)!", [e name], [e reason]);		}				[eventIsDone set];		}@end/******************************************************************************/@interface DumpThreadClass : NSObject{		}-(void)run : (id)arg;@end@implementation DumpThreadClass-(void)run : (id)arg{		//printf("On DumpThreadClass::run : %d\r\n", [self retainCount]);}-(void)dealloc{		//printf("On DumpThreadClass::dealloc\r\n");		[super dealloc];}@end/* 因为cocoa在pthread创建的线程下，必须设置为multithread模式，设置的办法就是用NSThread至少创建一个线程，因此这里创建一个无用线程 */static void putCocoaIntoMultithreadedMode() {				if([NSThread isMultiThreaded])		{				DumpThreadClass *dumb = [[DumpThreadClass alloc] init];				[NSThread detachNewThreadSelector : @selector(run:) 										 toTarget : dumb									   withObject : nil				 ];								while(![NSThread isMultiThreaded])				{						usleep(1 * 1000);				}				[dumb release];		}		}/******************************************************************************/static void* __thread_routine(void *param){		assert(param != NULL);					assert([NSThread isMultiThreaded]);						NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];				ThreadData *thd_data = (ThreadData*)param;				if(thd_data != nil)		{				[thd_data run];		}				[pool drain];				return NULL;}@implementation ARThread +(void)	sleep : (NSTimeInterval)milliseconds{		long m = (long)milliseconds;				usleep(m * 1000);		}+(void) yield{		pthread_yield_np();}-(id)init{		assert(NO);		return [self initWithTarget : nil selector : nil argument : nil];}-(id)	initWithTarget : (id)obj 			selector : (SEL)sel 			argument : (id)arg{				self = [super init];				if(self)		{				putCocoaIntoMultithreadedMode();								data = [[ThreadData alloc] init];				data.target = obj;				data.action = sel;				data.arg = arg;												pthread_attr_t attr;				pthread_attr_init(&attr);				pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);								memset(&thread, 0, sizeof(thread));								if(pthread_create(&thread, &attr, __thread_routine, (void*)data) != 0)				{						@throw [ARSystemException exceptionWithReason : @"cannot start thread"];				}								pthread_attr_destroy(&attr);								[data waitForInitialized];		}		return (self);}-(void)dealloc{		[self join];				[data release];						[super dealloc];}-(void)	join{		[data waitForDone];		pthread_join(thread, NULL);}-(BOOL) joinTimeout : (NSTimeInterval) milliseconds{		if([data waitForDoneTimeout : milliseconds])		{				pthread_join(thread, NULL);				return YES;		}else		{				return NO;		}}-(BOOL)isActive{		if([self joinTimeout : 0])		{				return NO;		}else		{				return YES;		}}-(void)setPriority : (int)prio{		struct sched_param param;		memset(&param, 0, sizeof(param));		param.sched_priority = prio;		if(pthread_setschedparam(thread, SCHED_OTHER, &param) != 0)		{				@throw [ARSystemException exceptionWithReason : @"cannot set thread priority"];		}}-(void) getPriority : (int*)prio{		assert(prio != NULL);		int policy = 0;		struct sched_param param;		memset(&param, 0, sizeof(param));				if(pthread_getschedparam(thread, &policy, &param) == 0)		{				*prio = param.sched_priority;		}else		{				@throw [ARSystemException exceptionWithReason : @"cannot get thread priority"];		}}@end