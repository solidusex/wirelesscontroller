/* *  TestBuildParser.c *  Test * *  Created by liu peng on 10/1/11. *  Copyright 2011 none. All rights reserved. * */#include "TestBuildParser.h"						using namespace ARSpace;static void	AR_STDCALL	__free_node(psrNode_t *node, void *ctx){		AR_ASSERT(node != NULL);		free(node);}static bool_t	AR_STDCALL	__on_parse_error(const psrToken_t *tok, const size_t expected[], size_t count, void *ctx){				return true;		}static const psrHandler_t		__def_handler = {		__on_parse_error,		__free_node};static void AR_STDCALL report_build_func(const cfgReportInfo_t *report, void *context){		switch(report->type)		{				case CFG_REPORT_MESSAGE_T:						wprintf(L"%ls\r\n", report->std_msg.message);						break;				case CFG_REPORT_ERROR_T:						wprintf(L"%ls\r\n", report->error.err_msg);						break;				case CFG_REPORT_ERROR_LEX_T:						wprintf(L"%ls\r\n", report->lex_error.msg);						break;				case CFG_REPORT_ERROR_SYNTAX_T:						wprintf(L"%ls\r\n", report->syntax_error.msg);						break;				case	CFG_REPORT_WARNING_SYNTAX_T:						wprintf(L"%ls\r\n", report->warning.msg);						break;				default:						AR_ASSERT(false);		}}static void	AR_STDCALL	__report_io_error_func(int_t level, const wchar_t *msg, void *ctx){		wprintf(L"%ls\r\n", msg);}static void	AR_STDCALL	__report_io_print_func(const wchar_t *msg, void *ctx){				wprintf(L"%ls\r\n", msg);} bool_t generate_by_cfg(const cfgConfig_t *cfg){				bool_t	has_error = false;		lex_t			*lexer = Lex_Create();				psrGrammar_t	*grammar = Parser_CreateGrammar(&__def_handler);						for(size_t i = 0; i < cfg->name_cnt; ++i)		{				const cfgName_t		*name = &cfg->name[i];								if(!Lex_InsertName(lexer, name->name, name->regex))				{						wprintf(L"Name Error : \"%ls : %ls\"", name->name, name->regex);						has_error = true;				}		}				for(size_t i = 0; i < cfg->tok_cnt; ++i)		{				const cfgToken_t		*tok = &cfg->tok[i];								lexAction_t	action;				action.is_skip = tok->is_skip;				action.priority = tok->lex_prec;				action.value = tok->tokval;				if(!Lex_InsertRule(lexer, tok->regex, &action))				{						wprintf(L"Token Error :  \"%ls : %ls\"", tok->name, tok->regex);						has_error = true;						//continue;				}								if(tok->is_skip || tok->tokval == 0)				{						continue;				}								if(!Parser_InsertTerm(grammar, tok->name, tok->tokval, PARSER_ASSOC_NONASSOC, 0, NULL))				{											wprintf(L"Term Error : \"%ls : %ls\"", tok->name, tok->regex);						has_error = true;				}		}				for(size_t i = 0; i < cfg->prec_cnt; ++i)		{				const cfgPrec_t		*prec = &cfg->prec[i];								for(size_t k = 0; k < prec->count; ++k)				{						psrTermInfo_t *info = Parser_GetTermSymbInfoByName(grammar,prec->prec_tok_set[k]);												if(info == NULL)						{								if(!Parser_InsertTerm(grammar, prec->prec_tok_set[k], prec->prec_tok_val[k], prec->assoc, prec->prec_level, NULL))								{										wprintf(L"Prec Error : \"%ls\"!", prec->prec_tok_set[k]);										has_error = true;								}						}else						{								info->assoc = prec->assoc;								info->prec = prec->prec_level;						}				}						}						for(size_t i = 0; i < cfg->rule_cnt; ++i)		{				const cfgRule_t		*rule = &cfg->rule[i];								wchar_t str[4096];								swprintf(str, 4096, L"%ls : %ls", rule->lhs, rule->rhs);				if(!Parser_InsertRuleByStr(grammar, str, rule->prec_tok,  NULL, 0))				{						wprintf(L"Rule Error : \"%ls\"!", str);						has_error = true;				}		}								if(cfg->start.start_rule != NULL)		{				bool has_start_rule = true;								for(size_t i = 0; i < cfg->rule_cnt; ++i)				{						if(AR_wcscmp(cfg->start.start_rule, cfg->rule[i].lhs) == 0)						{								has_start_rule = false;								break;						}				}												if(has_start_rule || !Parser_SetStartRule(grammar, cfg->start.start_rule))				{						has_error = true;						wprintf(L"Start Rule Error : \"%ls\"!", cfg->start.start_rule);				}		}				{								arIOCtx_t	io_context = 				{						__report_io_error_func,						__report_io_print_func,				};								if(!Parser_CheckIsValidGrammar(grammar, &io_context))				{						has_error = true;				}		}										if(has_error)		{				Lex_Destroy(lexer);				Parser_DestroyGrammar(grammar);				return false;		}else		{								uint_64_t beg, end;								beg = AR_GetTime_Milliseconds();								Lex_GenerateTransTable(lexer);								const parser_t *parser = Parser_CreateParser(grammar, PARSER_LALR);												end = AR_GetTime_Milliseconds();								wprintf(L"Build Parser Tick count %u\r\n", (int)(end-beg));								size_t conflict = Parser_CountParserConflict(parser);								if(conflict > 0)				{						wprintf(L"The grammar has %d conflicts !\r\n", (uint_32_t)conflict);				}								Lex_Destroy(lexer);				Parser_DestroyParser(parser);				Parser_DestroyGrammar(grammar);								return true;		}												return true;}static void __GenerateParsertest(){		#define GMR_PATH L"/Users/solidussnakeex/Desktop/Temp/SQL.gmr"				arTxtBom_t		bom;		arString_t *str = AR_CreateString();				if(!AR_LoadBomTextFile(GMR_PATH, &bom, str))		{				AR_ASSERT(false);		}						cfgReport_t	report = {report_build_func, NULL};				const cfgConfig_t *cfg = CFG_CollectGrammarConfig(AR_GetStringCString(str), &report);						if(cfg == NULL || cfg->has_error)		{				goto FAILED_POINT;				}				if(!generate_by_cfg(cfg))		{				goto FAILED_POINT;			}				if(cfg)		{				CFG_DestroyGrammarConfig(cfg);				cfg = NULL;		}								FAILED_POINT:					if(cfg)		{				CFG_DestroyGrammarConfig(cfg);				cfg = NULL;		}				if(str)		{				AR_DestroyString(str);				str = NULL;		}		}void AR_GenerateParsertest(){		while(true)		{				__GenerateParsertest();				sleep(0);		}}